# Working with Streams and Lambda expressions

## Lambda
- Lambda expression: an anonymous method
- Functional programming: passing code as data
- Lambda expression helps to use functional programming in java
- Lambda expression always implements functional interface.
- Functional interfaces: java.util.function
- Lambda expression structure
```
    parameters -> body
   
    - parameter
        - parameter type is optional
        - no parameter: empty parentheses [ () -> body ]
        - single parameter: parentheses are optional [ (p) -> body ] [ p -> body ]
        - multiple parameter: parentheses required [ (p,q) -> body ]
    - body  
        - body can be block or single expression
        - for single expression, no return needed
        - for block, return is required [ () -> { statement1; statement2; return something; } ] 
```
- lambda expression can access final or effectively final variable
- effectively final variable means a variable that was assigned only once and not modified inside or outside lambda expression
- but for mutable object like arraylist we can use and modify the object inside or outside lambda


## Functional interface
- functional interface must have single abstract method
- can have static method, default method and inherited method from Object class
- ```@FunctionalInterface``` annotation is used to declare an interface function. but it's optional. if an interface contains single abstract method, then it is functional.
- if you use ```@FunctionalInterface``` in an interface, you can't write multiple abstract method. compiler will throw error.
- commonly used functional interfaces
```
    public interface Function<T, R> {
        R apply(T t);   // 1 input 1 output
    }
    
    public interface BiFunction<T, U, R> {
        R apply(T t, U u);  // 2 input 1 output
    }
    
    public interface Consumer<T> {
        void accept(T t);   // 1 input 0 output
    }
    
    public interface BiConsumer<T, U> {
        void accept(T t, U u);  // 2 input 0 output
    }
    
    public interface Supplier<T> {
        T get();    // 0 input 1 output
    }
    
    public interface Predicate<T> {
        boolean test(T t);  // 1 input 1 boolean output
    }
    
    public interface BiPredicate<T, U> {
        boolean test(T t, U u); // 2 input 1 boolean output
    }
    
    public interface UnaryOperator<T> extends Function<T, T> {
        T apply(T t);   // 1 input 1 output - same type
    }
    
    public interface BinaryOperator<T> extends BiFunction<T,T,T> {
        T apply(T t1, T t2);  // 2 input 1 output - same type
    }
```
- **functional composition**
  - have to study
- **specialized standard functional interface**
  - have to study
- 
